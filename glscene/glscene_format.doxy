/**
\page page_glscene_file_format GL Scene Graph File Format

[TOC]

The scene graph system's file format, exposed by the [parsing API](\ref module_glscene_parsing), is a fairly simple format.

Files are expected to be UTF-8 text files. The line ending sytle doesn't matter; the parser can handle anything. Also, the format uses C++-style comments (ie: `//` syntax).

# Basic Syntax # {#page_glscene_file_format_syntax}

This system uses a very rigid, well-defined basic syntax. Any sequence of non-number characters that is not bracketed by one of the delimiters listed below is treated as a keyword.

## Commands ## {#page_glscene_file_format_syntax_commands}

The general syntax is a sequence of commands. Every command begins with a keyword. Following that keyword is a sequence of parameters to that command, which can include strings or numbers.

In addition to parameters, some commands contain other commands; such commands are called "compound commands". Subcommands effectively define data within the compound command. A sequence of subcommands is terminated with the `end` keyword. Commands that cannot have subcommands do not use the `end` keyword.

Parameters can only be [strings](\ref page_glscene_file_format_syntax_strings) or [numbers](\ref page_glscene_file_format_syntax_numbers); they cannot be keywords (with a very few exceptions). Therefore a keyword defines a new command. Whether that new command is a sub-command of the previous command or a sibling command that simply followed the last command depends entirely on the last command itself.

Generally speaking, non-compound commands have at most 3 parameters. Commands with more complex data will be compound commands with sub-commands. This makes it easier to provide default values, as well as making the format more readable.

Each compound command defines what commands may be sub-commands of it. They also define the expected sequence of these commands. Some commands are more rigid than others, specifying a strict order of sub-commands. Some commands allow more complex relationships between sub-commands, such that a sub-command can reference a previously-defined sub-command, much like C/C++ typenames and scoping.

The general idea of the syntax looks like the following:

~~~~~~~~~~
command params
  sub-command params
  sub-command params
  sub-command params
    sub-sub-command params
	sub-sub-command params
  end
end

command params
  sub-command params
end
~~~~~~~~~~

## Strings ## {#page_glscene_file_format_syntax_strings}

The system uses a number of different kinds of user-provided "strings", each one bounded by a different pair of delimiter characters. Each kind of string has a specific function in the grammar, and using one string type when another is expected will result in an error. The different types of strings have different sets of legal characters.

The types of strings, and their delimiters, are:

String Type       | Delimiter
----------------- | ---------
`Identifier`      | `<Text>`
`Filename`        | `"Text"`
`GLSL Identifier` | `{Text}`
`Enumerator`      | `[Text]`
`Graph Name`      | `'Text'`

- `Identifier`: These strings are used as [identifier strings](\ref page_glscene_identifier_strings) within the scene graph. They name particular scene graph entities, like resources, nodes, and styles.

    Identifier string names can only contain (English) letters, numbers, and the characters "_", ".", and "-". They cannot contain spaces. These are limitations of the parser, not of the Scene Graph's identifier string system.
	
- `Filename`: These represent file names or strings to be passed to the parser's loader as filenames. They can contain any character except " (and end-line characters). Though if you want file loading to work, you should stick to characters that your file system can work with.

	While the Scene Graph can be in UTF-8 format, it is completely blind to Unicode itself. It will make no special effort to use any Unicode-based file loading.
	
- `GLSL Identifier`: These strings represent the name of an entity in a shader written in the OpenGL Shading Language. These are typically uniform names.

	The valid characters here are the legal characters for a GLSL identifer. However, OpenGL uniform names can be aggregated into structs and arrays. So the name of a uniform often includes several identifers, separated by characters like "." and "[]". Therefore, `{unifName.member}` denotes a legal GLSL identifier by the scene graph format even though technically it is not an "identifier" by GLSL's grammar.
	
- `Enumerator`: These strings represent a selection from one of a finite set of named possibilities. Texture filtering modes are an example of an enumerator. Unlike all other strings, they are not user *defined*; you can only use the enumerators that a particular command allows. If you use the wrong enumerators, you get an error. And they are case-sensitive, however no enumerators use uppercase characters.

- `Graph Name`: This is a string name to be used for a concept within a graph. These are specifically *not* [identifier strings](\ref page_glscene_identifier_strings). They do represent concepts in the scene graph or associated objects. Examples of these are layer names and mesh variants.

	Graph names can contain any character except ' (and end-line characters).

## Numbers ## {#page_glscene_file_format_syntax_numbers}

Some commands take numbers as parameters. In every case where a number is expected, that number is expected to conform to a specific type. The general types of numbers are:

1. unsigned integer: an integer value without a leading "-" sign.
2. signed integer: an integer value with a leading "-" sign.
3. floating-point value: any number with a decimal, which may have a leading "-" or "+" sign. Note that scientific notation (1.0+e5) is not allowed. Also, note that there must be a digit before the decimal. `.5` is not a valid floating-point number; it must be `0.5`

The types can be promoted from lower types to higher ones. So a command that expects you to provide a signed integer can also take an unsigned one. A command that takes a floating-point type will take any kind of number.

Note that the leading "-" sign must be directly adjacent to the numeral. So "- 5" is not the number -5; it's a minus sign followed by the unsigned integer 5.

### Vectors and Matrices ### {#page_glscene_file_format_syntax_numbers_vectors}

Some commands take vector or matrix types rather than a scalar. Such types must *always* be bounded by a pair of parenthesis, even if you are only passing one value.

Vector and matrix types have an expected number of values. To initialize these types, you must provide the expected number of values in the parenthesis, separated by spaces. Note that you *do not use commas* to separate entires. So `(5, 3)` will result in an error; use `(5 3)` instead.

Matrices in this system follow GLSL's conventions. They are *column major*; the first values are the first column of the matrix.

You may also initialize a vector or matrix with one value (which again *must* be in parenthesis). Following GLSL conventions, vectors initialized with a single value will copy the value to all components. Matrices initialized to a value 

Quaternions are a special form of vector value. A quaternion is expected to be normalized (though the system will normalize any you provide). As such, constructing them from a single value is pointless, unless that single value is 0.5, which represents a very specific orientiation. So for quaternions, you must provide 4 values.

Also, note that quaternions in this system do *not* follow GLM's asinine 
conventions. The W component comes *last*, not first.

# Resources # {#page_glscene_file_format_resources}

\verbatim
resources
//Commands
end
\endverbatim

A scene graph file must contain one or more `resources` commands. This command has sub-commands, so it must be terminated by `end`. Each sub-command represents a [different kind of resource](\ref module_glscene_resources) to be stored in the resulting glscene::SceneGraph object.

The sub-commands of a `resources` command can appear in any order and can appear multiple times. Each command defines a resource. All resource commands take, as their first parameter, an identifier string that represents the name of the resource being created. So they are all of the form: `command_name <resource_identifier>`. No two resources of the same type may use the same [identifier name](\ref page_glscene_identifier_strings).

Different `resources` commands in the same scene graph file (or referenced by them) are *not* independent. They are all aggregated together into a single glscene::SceneGraph's resource. So if two resources of the same type use the same identifier, they will fail even if the two commands are in different `resources` commands.

## Uniform Resource ## {#page_glscene_file_format_resources_uniform}

~~~~
uniform_res <resource_id> [type] (initial values)?
~~~~

The `uniform_res` command defines a uniform resource, as though by `ResourceRef::DefineUniform`. The resource name defines the 

The `type` defines how to interpret the `initial values` part. If the type is a scalar type, then the initial values must be a single number, though it may be in parentheses. If `type` is a vector or matrix type, then the initial values must be a parenthesized list of either a single number or the required number of values.

The `initial values` are optional. If they are not specified, then a default value of 0 is used for all scalars and vectors. Matrices default to the identity matrix.

All values provided must be convertible to the `type`'s value. A float is not convertible to an integer.

`type`   | Base Type    | Number of initial values
-------- | ------------ | -------------------------
`uint`   | unsigned int | 1
`uvec2`  | unsigned int | 2
`uvec3`  | unsigned int | 3
`uvec4`  | unsigned int | 4
`int`    | signed int   | 1
`ivec2`  | signed int   | 2
`ivec3`  | signed int   | 3
`ivec4`  | signed int   | 4
`float`  | float        | 1
`vec2`   | float        | 2
`vec3`   | float        | 3
`vec4`   | float        | 4
`mat2`   | float        | 4
`mat3`   | float        | 9
`mat4`   | float        | 16

## Sampler Resource ## {#page_glscene_file_format_resources_sampler}

\verbatim
sampler_res <resource_id>
//Commands
end
\endverbatim

The `sampler_res` command creates a sampler resource, as if by glscene::ResourceRef::DefineSampler(). The subcommands of the sampler each represent a field in the glscene::SamplerInfo data structure. They can be defined in any order, but only one can appear in a particular `sampler_res` command. The default values from glscene::SamplerInfo will be used if you do not specify a value.

The valid subcommands are as follows:

- `mag [magnification_filter]`: Specifies the `GL_TEXTURE_MAG_FILTER` value. The enumeration must be one of these:
	- `nearest`
	- `linear`
- `min [minifcation_filter]`:  Specifies the `GL_TEXTURE_MIN_FILTER` value. The enumeration must be one of these:
	- `nearest`
	- `linear`
	- `nearest_mip_nearest`
	- `nearest_mip_linear`
	- `linear_mip_nearest`
	- `linear_mip_linear`
- `compare [comparison_mode]`: Specifies the `GL_TEXTURE_COMPARE_FUNC` value. The enumeration must be one of these:
	- `less`
	- `less_equal`
	- `greater`
	- `greater_equal`
	- `equal`
	- `not_equal`
	- `pass`
	- `fail`
- `wrap_(str) [wrapping_mode]`: These are three separate commands, with a choice of "s", "t" or "r" for the final letter (the paretheses represent the choice; they're not part of the command). They specify the corresponding `GL_TEXTURE_WRAP_(STR)` value. The enumeration must be one of these:
	- `edge_clamp`
	- `border_clamp`
	- `repeat`
	- `mirror_repeat`
- `aniso number`: Specifies the anisotropic filtering value. An unparethesized number is provided; the number may be any form of integer or float. However, numbers less than 0 will be rejected.

## Camera Resource ## {#page_glscene_file_format_resources_camera}

\verbatim
camera_res <resource_id> [mouse_button] [keyboard_side]
//Commands
end
\endverbatim

The `camera_res` command creates a camera resource, as if by glscene::ResourceRef::DefineCamera(). The `mouse_button` enum specifies which button is used by the camera. The `keyboard_side` enum specifies if the left or right side controls of the camera are used.

The `mouse_button` enum must be one of the following:

- `left_btn`: The camera is rotated by pressing the left mouse button.
- `right_btn`: The camera is rotated by pressing the right mouse button.

The `keyboard_side` enum must be one of the following:

- `left_kbd`: The camera uses WASDQE to move.
- `right_kbd`: The camera uses IJKLUO to move.

The sub-commands of the camera resource define the contents of glutil::ViewData and glutil::ViewScale, to be passed to glutil::MousePole. They can be in any order, but most of them are required.

The valid sub-commands are:

- `target (position)`: **Required**. This defines the current look-at point of the camera, through glutil::ViewData::targetPos. `position` must be a vector of floats, so it must be in parentheses.
- `orient (quaternion)`: This defines the current orientation of the camera, relative to the lookat point, through glutil::ViewData::orient. `quaternion` must be a vector of 4 floats, so it must be in parentheses. When not specified, it defaults to the identity quaternion.
- `spin (initial spin)`: This defines the current spin orientation of the camera, through glutil::ViewData::degSpinRotation. `initial spin` must be a single float. When not specified, it defaults to 0.
- `radius (initial) (minimum) (maximum)`: **Required**. This defines the starting distance from the look-at point, as well as the minimum and maximum distance values. The three values are a single float each. They must be larger than 0, the `minimum` must be smaller than the `maximum`, and the `initial` value must be between them.
- `radius_delta (small) (large)`: **Required**. This defines the large and small changes in distance from the view target, as through by glutil::ViewScale::smallRadiusDelta and glutil::ViewScale::largeRadiusDelta respectively. These values are each a single float. They must be larger than 0, and the `small` value must be larger than the `large`.
- `pos_delta (small) (large)`: **Required**. This defines the large and small changes in the camera view target position, as though by glutil::ViewScale::smallPosOffset and glutil::ViewScale::largePosOffset respectively. These values are each a single float. They must be larger than 0, and the `small` value must be larger than the `large`.
- `rotation_scale (scale)`: **Required**. This defines the number of degrees to rotate the view per window space pixel the mouse moves when dragging, as if by glutil::ViewScale::rotationScale. This value is a single float and must be larger than 0.

## Uniform and Storage Buffer Resource ## {#page_glscene_file_format_resources_buffer}

\verbatim
uniform_buffer_res <resource_id> (size) `creation`
storage_buffer_res <resource_id> (size) `creation`
\endverbatim

Uniform buffer resources and shader storage buffer resources are defined in identical ways; the only difference is which keyword is used to create them: `uniform_buffer_res` or `storage_buffer_res`. They do have different namespaces, so a uniform buffer `resource_id` can match a storage buffer's id.

The `size` is an unsigned integer that defines how many bytes will be in the bound buffer region. It is a single, unparenthesized value.

The `creation` parameter is a bit more complex. Buffer objects can either be created by the parsing system itself or by the user. To state that the system should created the buffer, `creation` must be an enumeration that defines the usage hint for the buffer object. This usage will be used when creating the buffer.

So the command `uniform_buffer_res <ident> 512 [static_draw]` will create a 512-byte buffer object, and who's usage is `GL_STATIC_DRAW`. Buffers created by the system will be owned by the scene graph. Also, the offset for these bindings will be 0, so that they always use the entire buffer.

To state that a buffer object is to be created by the user, `creation` must be the keyword `placeholder`. This will create the buffer resource as if by glscene::ResourceRef::DefineUniformBufferBindingIncomplete() or glscene::ResourceRef::DefineStorageBufferBindingIncomplete(). Therefore, you must, after the parser has generated the glscene::SceneGraph, complete the buffer binding by providing a buffer object and offset.

The valid enumerator values for `creation` are:

<table>
<tr><td>`static_draw`</td><td>`static_read`</td><td>`static_copy`</td></tr>
<tr><td>`dynamic_draw`</td><td>`dynamic_read`</td><td>`dynamic_copy`</td></tr>
<tr><td>`stream_draw`</td><td>`stream_read`</td><td>`stream_copy`</td></tr>
</table>

## Program Resource ## {#page_glscene_file_format_resources_program}

\verbatim
program_res <resource_id> [separate]?
//Commands
end
\endverbatim

The `program_res` command defines a program resource, as if by glscene::ResourceRef::DefineProgram(). The sub-commands define the parameters for glscene::ProgramInfo. They can be defined in any order.

glscene::ResourceRef::DefineProgram() takes a previously created program object. The scene graph file system takes a different approach. Individual shader files are specified, which it will load, compile, and link into a program. So `program_res` has a number of sub-commands for specifying shader files for the program.

`separate` is an optional enumeration. If you provide it (and it can only be that value), then the program will be linked with the `GL_PROGRAM_SEPARATE` flag.

The list of sub-commands must include at least one shader file specifier. The shader specifier sub-commands are as follows:

- `vert`
- `tess_ctrl`
- `tess_eval`
- `geom`
- `frag`

Following any of these specifiers is a filename string defining which shader to load. You may provide shaders of the same type multiple times. Each one will be used to generate a separate shader object, and they will all be linked together.

The other sub-commands are as follows:

- `mtc {uniform name}`: Specifies the name of a `mat4` uniform variable in the program that will be given the model-to-camera matrix by the scene graph system. This sub-command may only be specified once.
- `nmtc {uniform name}`: Specifies the name of a `mat3` uniform variable in the program that will be given the normal`s model-to-camera matrix by the scene graph system. This sub-command may only be specified once.
- `nctm {uniform name}`: Specifies the name of a `mat3` uniform variable in the program that will be given the normal`s camera-to-model matrix by the scene graph system. This sub-command may only be specified once.
- `sampler {uniform name} (texture unit)`: Specifies the name of a uniform variable of a sampler type which will be assigned the value `texture unit`. `texture unit` is an unsigned integer.
- `image {uniform name} (image unit)`: Specifies the name of a uniform variable of an image type which will be assigned the value `image unit`. `image unit` is an unsigned integer.
- `uniform_buffer {block name} (block binding)`: Specifies that the uniform block named `block name` will be assigned the binding point `block binding`, which is an unsigned integer.
- `storage_buffer {block name} (block binding)`: Specifies that the shader storage block named `block name` will be assigned the binding point `block binding`, which is an unsigned integer.

## Mesh Resource ## {#page_glscene_file_format_resources_mesh}

~~~~
mesh_res <resource_id> `creation` (param1) (param2)
~~~~

This creates a mesh resource, as if by glscene::ResourceRef::DefineMesh(). The `creation` parameter may be one of the following:

- The `placeholder` keyword. This causes the system to create an incomplete mesh resource. So the user is expected to define the mesh later with glscene::ResourceRef::DefineMesh().
- A "" filename string. This is a filename that will be loaded by the loader.
- An enumerator. This defines which [GL Mesh mesh generator function](module_glmesh_mesh_generator) to use to generate the mesh. The generators can take up to two parameters. These parameters are unsigned integers. If you use the wrong number of parameters, an error will result. The available generators, with the number of parameters, are:
	- `ground_plane numXVerts numYVerts`: Per glmesh::gen::GroundPlane()
	- `unit_axes`: Per glmesh::gen::Axes()
	- `cube_block numCubesOnEdge`: Per glmesh::gen::CubeBlock()
	- `cube_pyramid numCubesTall`: Per glmesh::gen::CubePyramid()
	- `tetrahedron`: Per glmesh::gen::Tetrahedron()
	- `cube`: Per glmesh::gen::Cube()
	- `octahedron`: Per glmesh::gen::Octahedron()
	- `dodecahedron`: Per glmesh::gen::Dodecahedron()
	- `icosahedron`: Per glmesh::gen::Icosahedron()
	- `unit_sphere numHorizSlices numVertSlices`: Per glmesh::gen::UnitSphere()

The two unsigned integer parameters can only be used with GL Mesh mesh generators.

## Texture Resource ## {#page_glscene_file_format_resources_texture}

~~~~
texture_res <resource_id> `creation`
~~~~

This creates a texture resource, as if by glscene::ResourceRef::DefineTexture(). The `creation` parameter may be one of the following:

- The `placeholder` keyword. This causes the system to create an incomplete texture resource. So the user is expected to define the texture later with glscene::ResourceRef::DefineTexture().
- A "" filename string. This is a filename that will be loaded by the loader.

# Scene Graph # {#page_glscene_file_format_syntax_scene}

~~~~
scene
  //Commands
end
~~~~

The last command in a file must be a `scene` command. A file can only contain one `scene` command; it may not have more or fewer. And no `resources` commands (or any other commands) may follow it. The `scene` command is a compound command.

The `scene` command is more rigidly structured in its content than the top-level `resources` command. The following commands must be provided, in order. Some of them are optional:

- `layer_defs`: Required. The parameters to this command are a series of graph names. These represent the names of the layers, as provided to glscene::SceneGraph::SceneGraph(), and the order you place them in the list is the order that they will be provided in.
- `variant_check`: Optional. The parameters to this command are a series of identifier strings. If you provide this command, the use of any variant names not listed here will result in a parse error.
- One or more `node` commands, [as described below](\ref page_glscene_file_format_syntax_scene_node).

\par A Word on the Root Node
The [GL Scene Graph](\ref module_glscene) has a root node. And glscene::SceneGraph freely allows you to fetch this node, add variants to it, change its transforms, and play with it as though it were any other node (mostly). However, the scene graph file format does not expose this functionality. You cannot set any of these things on the root node. This is quite deliberate.
\par
Becaue the root node is restricted in its functionality, such as re-parenting, deleting, and querying-by-name, the scene file format encourages you to create your own root. This makes it easier for you to move things around dynamically. It also makes it easier for you to change things later, since you can copy node definitions around more freely.

## Node ## {#page_glscene_file_format_syntax_scene_node}

\verbatim
node <node_id>?
//Commands
end
\endverbatim

The `node` command defines a child node in the scene graph system. It is the child of whatever node it is defined in; if it is defined in the `scene` command, then it is a child of the root.

`node_id` is optional. If a node does not have one, then you cannot query the node by name in the glscene::SceneGraph. If you do provide a `node_id` name, it *must* be unique; no other node can have the same identifier.

The contents of a node are rigidly ordered. The sub-commands must be provided in the following order:

- `layers`: Optional. This provides a list of layers that the node is a member of. This list has some complexities to it, so there is [a section dedicated to them](\ref page_glscene_file_format_syntax_scene_node_layers).

### Node Layers ### {#page_glscene_file_format_syntax_scene_node_layers}

~~~~
layers 'layer_to_add' +'layer_to_inherit' -'layer_to_remove' +-'layer_to_remove_and_inherit_removal'
~~~~

The parameters of `layers` is a list of graph names that define which layers this node is associated with. They can also be inherited, such that child nodes will be members of those layers without a `layers` command mentioning that layer.

It is an error to specify a layer name that is not mentioned in the `layer_defs` list in the `scene` node.

Each layer name in the list can be prefixed. The prefixes mean the following:

- No prefix: The current node will be a member of that layer. Child node layers are unaffected.
- `+`: The current node will be a member of that layer. All child nodes will also be a member of that layer.
- `-`: The current node will not be a member of that layer. Useful for removing an inherited layer. Child node layers are unaffected.
- `+-`: The current node will not be a member of that layer. All child nodes will also *not* be a member of that layer.

Note that `-+` is not a valid prefix. The `+` must always come first.

All layer additions are processed in order, with latter commands overriding previous ones. For example:

~~~~
layers 'shadow' 'main' -'shadow'
~~~~

The node with this command will be a member of 'main' and any inherited layers. The `-'shadow'` layer overrides the first one because it came last. Similarly:

~~~~
layers -'shadow' 'main' 'shadow'
~~~~

This will put the node in 'main' and 'shadow', in addition to any inherited layers.

You can do even more complex things through this with inheritance:

~~~~
layers 'main' +'shadow' -'shadow'
~~~~

The current node will only have 'main' (and any inherited). It's children will inherit 'shadow'. The `-'shadow'` parameter is what causes the current node to no longer be in 'shadow', but the `-` prefix *does not affect inheritance*.

Similarly:

~~~~
layers +-'shadow' 'shadow'
~~~~

This will put the current node in 'shadow', but all child nodes will not be in 'shadow'.

**/




